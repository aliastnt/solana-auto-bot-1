# coding: utf-8
import os
import sys
import logging

# Th∆∞ vi·ªán Telegram bot (python-telegram-bot 13.15)
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters

# Th∆∞ vi·ªán Solana RPC
from solana.rpc.api import Client

# Th∆∞ vi·ªán Solders (cho Keypair, Pubkey, v√† System Program)
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.system_program import TransferParams, transfer

# C√°c th∆∞ vi·ªán kh√°c
import base58
import requests
from apscheduler.schedulers.background import BackgroundScheduler
import pytz

# Thi·∫øt l·∫≠p logging ƒë·ªÉ theo d√µi bot
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)

# ƒê·ªçc token c·ªßa bot v√† private key Solana t·ª´ bi·∫øn m√¥i tr∆∞·ªùng (n·∫øu c√≥)
TOKEN = os.environ.get("BOT_TOKEN")
INITIAL_PRIVKEY = os.environ.get("SOL_PRIVATE_KEY")

# Bi·∫øn to√†n c·ª•c l∆∞u tr·ªØ tr·∫°ng th√°i v√≠ v√† c·∫∑p token ƒëang theo d√µi
user_keypair = None  # Keypair ng∆∞·ªùi d√πng (s·∫Ω ƒë∆∞·ª£c g√°n sau khi /connect)
user_pubkey = None   # ƒê·ªãa ch·ªâ v√≠ (chu·ªói base58) t∆∞∆°ng ·ª©ng v·ªõi user_keypair
tracking_pair = None  # ID c·∫∑p token DexScreener ƒëang theo d√µi (chu·ªói)
alert_price = None    # Ng∆∞·ª°ng gi√° ƒë·∫∑t c·∫£nh b√°o (float USD)
alert_direction = None  # H∆∞·ªõng bi·∫øn ƒë·ªông gi√° c·∫ßn c·∫£nh b√°o ("up" ho·∫∑c "down")
alert_chat_id = None   # ID chat s·∫Ω nh·∫≠n c·∫£nh b√°o gi√°

# N·∫øu c√≥ private key ban ƒë·∫ßu trong bi·∫øn m√¥i tr∆∞·ªùng, t·ª± ƒë·ªông kh·ªüi t·∫°o Keypair
if INITIAL_PRIVKEY:
    try:
        user_keypair = Keypair.from_base58_string(INITIAL_PRIVKEY)
        user_pubkey = str(user_keypair.pubkey())
        logging.info(f"Loaded wallet from ENV with address: {user_pubkey}")
    except Exception as e:
        logging.error(f"ENV SOL_PRIVATE_KEY invalid: {e}")
        user_keypair = None
        user_pubkey = None

# K·∫øt n·ªëi RPC Solana (m·∫∑c ƒë·ªãnh d√πng mainnet, c√≥ th·ªÉ ƒë·ªïi sang devnet n·∫øu c·∫ßn)
solana_rpc_url = os.environ.get("SOLANA_RPC_URL", "https://api.mainnet-beta.solana.com")
client = Client(solana_rpc_url)
logging.info(f"Connected to Solana RPC: {solana_rpc_url}")

# H·∫±ng s·ªë quy ƒë·ªïi
LAMPORTS_PER_SOL = 1000000000

# Handler cho l·ªánh /start
def start(update, context):
    update.message.reply_text(
        "ü§ñ Xin ch√†o! ƒê√¢y l√† bot giao d·ªãch Solana.\n"
        "B·∫°n c√≥ th·ªÉ k·∫øt n·ªëi v√≠ Solana c·ªßa m√¨nh ho·∫∑c t·∫°o v√≠ m·ªõi b·∫±ng l·ªánh /connect.\n"
        "C√°c l·ªánh kh·∫£ d·ª•ng:\n"
        "- /connect <PRIVATE_KEY>: K·∫øt n·ªëi v√≠ (private key ƒë·ªãnh d·∫°ng base58)\n"
        "- /connect new: T·∫°o v√≠ Solana m·ªõi\n"
        "- /address: Xem ƒë·ªãa ch·ªâ v√≠ hi·ªán t·∫°i\n"
        "- /balance: Xem s·ªë d∆∞ SOL c·ªßa v√≠\n"
        "- /setpair <ID>: Ch·ªçn c·∫∑p token (DexScreener pair address) ƒë·ªÉ theo d√µi\n"
        "- /price: Xem gi√° hi·ªán t·∫°i c·ªßa c·∫∑p token ƒë√£ ch·ªçn\n"
        "- /alert <GI√Å_USD>: ƒê·∫∑t c·∫£nh b√°o gi√° cho c·∫∑p token\n"
        "- /send <ƒê·ªäA_CH·ªà> <S·ªê_SOL>: Chuy·ªÉn SOL t·ªõi ƒë·ªãa ch·ªâ kh√°c\n"
        "- /help: Xem h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng"
    )
    # N·∫øu bot ch∆∞a c√≥ v√≠, nh·∫Øc ng∆∞·ªùi d√πng k·∫øt n·ªëi
    if user_keypair is None:
        update.message.reply_text(
            "üí° B·∫°n ch∆∞a k·∫øt n·ªëi v√≠. H√£y d√πng /connect <private_key> ho·∫∑c /connect new ƒë·ªÉ ti·∫øp t·ª•c."
        )

# Handler cho l·ªánh /help (hi·ªÉn th·ªã t∆∞∆°ng t·ª± /start)
def help_command(update, context):
    start(update, context)

# Handler cho l·ªánh /connect (k·∫øt n·ªëi ho·∫∑c t·∫°o v√≠)
def connect(update, context):
    global user_keypair, user_pubkey, alert_price, alert_direction, alert_chat_id
    args = context.args
    if len(args) == 0:
        update.message.reply_text("Vui l√≤ng cung c·∫•p kho√° b√≠ m·∫≠t (private key) d·∫°ng base58 ho·∫∑c nh·∫≠p 'new' ƒë·ªÉ t·∫°o v√≠ m·ªõi.")
        return
    key_str = args[0].strip()
    if key_str.lower() in ("new", "tao", "t·∫°o"):
        # T·∫°o v√≠ Solana m·ªõi
        new_kp = Keypair()
        new_pub = new_kp.pubkey()
        user_keypair = new_kp
        user_pubkey = str(new_pub)
        # M√£ ho√° private key th√†nh chu·ªói base58 ƒë·ªÉ hi·ªÉn th·ªã cho ng∆∞·ªùi d√πng
        priv_b58 = base58.b58encode(bytes(new_kp)).decode()
        update.message.reply_text(
            "‚úÖ ƒê√£ t·∫°o v√≠ Solana m·ªõi!\n"
            f"üîë Private key (base58): `{priv_b58}`\n"
            f"üîì ƒê·ªãa ch·ªâ (public key): `{user_pubkey}`\n\n"
            "H√£y **l∆∞u l·∫°i** kho√° b√≠ m·∫≠t tr√™n ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y. "
            "B·∫°n c√≥ th·ªÉ c·∫•u h√¨nh bi·∫øn m√¥i tr∆∞·ªùng `SOL_PRIVATE_KEY` v·ªõi gi√° tr·ªã tr√™n ƒë·ªÉ bot t·ª± ƒë·ªông k·∫øt n·ªëi v√≠ sau khi kh·ªüi ƒë·ªông l·∫°i."
        )
        # Xo√° c·∫£nh b√°o gi√° c≈© (n·∫øu c√≥) khi ƒë·ªïi v√≠
        alert_price = None
        alert_direction = None
        alert_chat_id = None
    else:
        # K·∫øt n·ªëi v√≠ b·∫±ng private key do ng∆∞·ªùi d√πng cung c·∫•p
        try:
            kp = Keypair.from_base58_string(key_str)
        except Exception as e:
            update.message.reply_text("‚ùå Kho√° b√≠ m·∫≠t kh√¥ng h·ª£p l·ªá. ƒê·∫£m b·∫£o b·∫°n nh·∫≠p ƒë√∫ng chu·ªói base58 c·ªßa private key.")
            return
        user_keypair = kp
        user_pubkey = str(kp.pubkey())
        update.message.reply_text(f"‚úÖ ƒê√£ k·∫øt n·ªëi v√≠ Solana! ƒê·ªãa ch·ªâ v√≠: `{user_pubkey}`")
        # Xo√° b·∫•t k·ª≥ c·∫£nh b√°o gi√° c≈© n√†o khi thay ƒë·ªïi v√≠
        alert_price = None
        alert_direction = None
        alert_chat_id = None

# Handler cho l·ªánh /address (ho·∫∑c /wallet) - hi·ªÉn th·ªã ƒë·ªãa ch·ªâ v√≠ hi·ªán t·∫°i
def address(update, context):
    if user_pubkey:
        update.message.reply_text(f"ƒê·ªãa ch·ªâ v√≠ c·ªßa b·∫°n: `{user_pubkey}`")
    else:
        update.message.reply_text("üîé Ch∆∞a c√≥ v√≠ ƒë∆∞·ª£c k·∫øt n·ªëi. H√£y d√πng /connect ƒë·ªÉ k·∫øt n·ªëi v√≠ Solana c·ªßa b·∫°n.")

# Handler cho l·ªánh /balance - l·∫•y s·ªë d∆∞ SOL c·ªßa v√≠
def balance(update, context):
    if user_pubkey is None:
        update.message.reply_text("üí∞ B·∫°n ch∆∞a k·∫øt n·ªëi v√≠. Vui l√≤ng d√πng /connect ƒë·ªÉ k·∫øt n·ªëi v√≠ tr∆∞·ªõc.")
        return
    try:
        # G·ªçi RPC get_balance
        balance_resp = client.get_balance(Pubkey.from_string(user_pubkey))
        lamports = balance_resp.value  # s·ªë lamport (1 SOL = 1e9 lamport)
        sol_amount = lamports / LAMPORTS_PER_SOL
        update.message.reply_text(f"S·ªë d∆∞: {lamports} lamport = {sol_amount:.9f} SOL")
    except Exception as e:
        logging.error(f"L·ªói khi get_balance: {e}")
        update.message.reply_text("‚ùå Kh√¥ng th·ªÉ l·∫•y s·ªë d∆∞. Vui l√≤ng th·ª≠ l·∫°i sau.")

# Handler cho l·ªánh /setpair - ƒë·∫∑t c·∫∑p token ƒë·ªÉ theo d√µi
def setpair(update, context):
    global tracking_pair
    if len(context.args) == 0:
        update.message.reply_text("Vui l√≤ng cung c·∫•p ID c·∫∑p token (DexScreener pair address) sau l·ªánh /setpair.")
        return
    pair_id = context.args[0].strip()
    tracking_pair = pair_id
    update.message.reply_text(f"‚úÖ ƒê√£ ch·ªçn c·∫∑p token: `{tracking_pair}`. B·∫°n c√≥ th·ªÉ d√πng /price ƒë·ªÉ xem gi√°.")

# Handler cho l·ªánh /price - l·∫•y gi√° hi·ªán t·∫°i c·ªßa c·∫∑p token ƒëang theo d√µi
def price(update, context):
    if tracking_pair is None:
        update.message.reply_text("B·∫°n ch∆∞a thi·∫øt l·∫≠p c·∫∑p token. H√£y d√πng /setpair <pair_id> tr∆∞·ªõc.")
        return
    try:
        url = f"https://api.dexscreener.com/latest/dex/pairs/solana/{tracking_pair}"
        res = requests.get(url, timeout=10)
        data = res.json()
        if "pairs" in data and data["pairs"]:
            info = data["pairs"][0]
            price_usd = float(info.get("priceUsd", 0.0))
            base_token = info.get("baseToken", {}).get("symbol", "")
            quote_token = info.get("quoteToken", {}).get("symbol", "USD")
            update.message.reply_text(
                f"üí± Gi√° hi·ªán t·∫°i c·ªßa c·∫∑p {base_token}/{quote_token}: {price_usd:.6f} USD"
            )
        else:
            update.message.reply_text("‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin gi√° cho c·∫∑p ƒë√£ ch·ªçn.")
    except Exception as e:
        logging.error(f"L·ªói khi l·∫•y gi√° DexScreener: {e}")
        update.message.reply_text("‚ùå L·ªói khi k·∫øt n·ªëi DexScreener ƒë·ªÉ l·∫•y gi√°.")

# Handler cho l·ªánh /alert - ƒë·∫∑t c·∫£nh b√°o gi√°
def alert(update, context):
    global alert_price, alert_direction, alert_chat_id
    if tracking_pair is None:
        update.message.reply_text("B·∫°n c·∫ßn /setpair tr∆∞·ªõc khi ƒë·∫∑t c·∫£nh b√°o gi√°.")
        return
    if len(context.args) == 0:
        update.message.reply_text("Vui l√≤ng cung c·∫•p m·ª©c gi√° USD ƒë·ªÉ c·∫£nh b√°o, v√≠ d·ª•: /alert 0.5")
        return
    try:
        threshold = float(context.args[0])
    except:
        update.message.reply_text("‚ùå M·ª©c gi√° kh√¥ng h·ª£p l·ªá. H√£y nh·∫≠p m·ªôt s·ªë (vd: 0.5)")
        return
    # L·∫•y gi√° hi·ªán t·∫°i ƒë·ªÉ x√°c ƒë·ªãnh h∆∞·ªõng bi·∫øn ƒë·ªông
    try:
        res = requests.get(f"https://api.dexscreener.com/latest/dex/pairs/solana/{tracking_pair}", timeout=5)
        data = res.json()
        current_price = float(data["pairs"][0]["priceUsd"]) if ("pairs" in data and data["pairs"]) else None
    except Exception:
        current_price = None
    if current_price is None:
        update.message.reply_text("‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y gi√° hi·ªán t·∫°i ƒë·ªÉ thi·∫øt l·∫≠p c·∫£nh b√°o.")
    else:
        if abs(threshold - current_price) < 1e-9:
            update.message.reply_text("‚ö†Ô∏è M·ª©c gi√° b·∫°n nh·∫≠p ƒëang b·∫±ng v·ªõi gi√° hi·ªán t·∫°i.")
        elif threshold > current_price:
            alert_direction = "up"
            alert_price = threshold
            alert_chat_id = update.effective_chat.id
            update.message.reply_text(
                f"üîî ƒê√£ ƒë·∫∑t c·∫£nh b√°o khi gi√° tƒÉng ƒë·∫øn {threshold:.6f} USD (gi√° hi·ªán t·∫°i: {current_price:.6f} USD)."
            )
        else:
            alert_direction = "down"
            alert_price = threshold
            alert_chat_id = update.effective_chat.id
            update.message.reply_text(
                f"üîî ƒê√£ ƒë·∫∑t c·∫£nh b√°o khi gi√° gi·∫£m xu·ªëng {threshold:.6f} USD (gi√° hi·ªán t·∫°i: {current_price:.6f} USD)."
            )

# Handler cho l·ªánh /send - g·ª≠i SOL t·ªõi ƒë·ªãa ch·ªâ kh√°c
def send(update, context):
    if user_keypair is None:
        update.message.reply_text("üö´ B·∫°n ch∆∞a k·∫øt n·ªëi v√≠ ƒë·ªÉ g·ª≠i SOL.")
        return
    # Y√™u c·∫ßu c√∫ ph√°p: /send <ƒë·ªãa_ch·ªâ_nh·∫≠n> <s·ªë_SOL>
    args = context.args
    if len(args) < 2:
        update.message.reply_text("Usage: /send <ƒë·ªãa_ch·ªâ v√≠ nh·∫≠n> <s·ªë_SOL>")
        return
    to_address = args[0].strip()
    amount_str = args[1].replace(",", ".")
    try:
        amount_sol = float(amount_str)
    except:
        update.message.reply_text("‚ùå S·ªë l∆∞·ª£ng SOL kh√¥ng h·ª£p l·ªá.")
        return
    if amount_sol <= 0:
        update.message.reply_text("‚ùå S·ªë l∆∞·ª£ng SOL ph·∫£i l·ªõn h∆°n 0.")
        return
    lamports = int(amount_sol * LAMPORTS_PER_SOL)
    try:
        # T·∫°o instruction chuy·ªÉn SOL b·∫±ng System Program
        ix = transfer(
            TransferParams(
                from_pubkey=user_keypair.pubkey(),
                to_pubkey=Pubkey.from_string(to_address),
                lamports=lamports
            )
        )
        # L·∫•y blockhash m·ªõi nh·∫•t ƒë·ªÉ h·ª£p l·ªá ho√° transaction
        latest_blockhash = client.get_latest_blockhash()
        blockhash_obj = latest_blockhash.value.blockhash
        # Bi√™n d·ªãch Message v0
        message = MessageV0.try_compile(
            payer=user_keypair.pubkey(),
            instructions=[ix],
            address_lookup_table_accounts=[],
            recent_blockhash=blockhash_obj
        )
        # T·∫°o transaction (ƒë√£ k√Ω b·∫±ng user_keypair)
        tx = VersionedTransaction(message, [user_keypair])
        # G·ª≠i transaction
        send_resp = client.send_transaction(tx)
        # L·∫•y tx signature (·ªü d·∫°ng chu·ªói base58)
        tx_signature = send_resp.value  # SendTransactionResp.value l√† signature
        update.message.reply_text(
            "‚úÖ ƒê√£ g·ª≠i th√†nh c√¥ng!\n"
            f"üîó Giao d·ªãch: https://solscan.io/tx/{tx_signature}\n"
            f"(Tx signature: {tx_signature})"
        )
    except Exception as e:
        logging.error(f"L·ªói khi g·ª≠i transaction: {e}")
        update.message.reply_text(f"‚ùå G·ª≠i SOL th·∫•t b·∫°i: {e}")

# Handler cho c√°c tin nh·∫Øn/command kh√¥ng x√°c ƒë·ªãnh
def unknown(update, context):
    update.message.reply_text("‚ùì Kh√¥ng hi·ªÉu y√™u c·∫ßu. G√µ /help ƒë·ªÉ xem h∆∞·ªõng d·∫´n.")

# Thi·∫øt l·∫≠p scheduler ƒë·ªÉ ki·ªÉm tra gi√° ƒë·ªãnh k·ª≥ (ph·ª•c v·ª• /alert)
tz = pytz.timezone("Asia/Ho_Chi_Minh")
scheduler = BackgroundScheduler(timezone=tz)

def price_check_job():
    global alert_price, alert_direction, alert_chat_id, tracking_pair
    if alert_price is None or alert_direction is None or tracking_pair is None:
        return  # kh√¥ng c√≥ c·∫£nh b√°o n√†o
    try:
        res = requests.get(f"https://api.dexscreener.com/latest/dex/pairs/solana/{tracking_pair}", timeout=5)
        data = res.json()
        if "pairs" in data and data["pairs"]:
            current_price = float(data["pairs"][0]["priceUsd"])
        else:
            current_price = None
    except Exception as e:
        logging.error(f"L·ªói c·∫≠p nh·∫≠t gi√° ƒë·ªãnh k·ª≥: {e}")
        current_price = None
    if current_price is None:
        return
    # Ki·ªÉm tra ƒëi·ªÅu ki·ªán k√≠ch ho·∫°t c·∫£nh b√°o
    if alert_direction == "up" and current_price >= alert_price:
        # Gi√° tƒÉng v∆∞·ª£t ng∆∞·ª°ng
        try:
            bot.send_message(alert_chat_id, f"üîî Gi√° ƒë√£ tƒÉng l√™n {current_price:.6f} USD, v∆∞·ª£t ng∆∞·ª°ng {alert_price:.6f} USD!")
        except Exception as e:
            logging.error(f"Kh√¥ng g·ª≠i ƒë∆∞·ª£c tin nh·∫Øn c·∫£nh b√°o: {e}")
        # T·∫Øt c·∫£nh b√°o sau khi g·ª≠i
        alert_price = None
        alert_direction = None
    elif alert_direction == "down" and current_price <= alert_price:
        # Gi√° gi·∫£m xu·ªëng d∆∞·ªõi ng∆∞·ª°ng
        try:
            bot.send_message(alert_chat_id, f"üîî Gi√° ƒë√£ gi·∫£m xu·ªëng {current_price:.6f} USD, d∆∞·ªõi ng∆∞·ª°ng {alert_price:.6f} USD!")
        except Exception as e:
            logging.error(f"Kh√¥ng g·ª≠i ƒë∆∞·ª£c tin nh·∫Øn c·∫£nh b√°o: {e}")
        alert_price = None
        alert_direction = None

# Th√™m job ki·ªÉm tra gi√° 10 gi√¢y m·ªôt l·∫ßn
scheduler.add_job(price_check_job, "interval", seconds=10)
scheduler.start()

# Kh·ªüi ƒë·ªông bot Telegram
if __name__ == "__main__":
    if not TOKEN:
        logging.error("Ch∆∞a c·∫•u h√¨nh BOT_TOKEN. Tho√°t ch∆∞∆°ng tr√¨nh.")
        sys.exit(1)
    updater = Updater(TOKEN, use_context=True)
    dp = updater.dispatcher

    # ƒêƒÉng k√Ω c√°c handler cho bot
    dp.add_handler(CommandHandler("start", start))
    dp.add_handler(CommandHandler("help", help_command))
    dp.add_handler(CommandHandler("connect", connect))
    dp.add_handler(CommandHandler("address", address))
    dp.add_handler(CommandHandler("wallet", address))  # alias /wallet cho /address
    dp.add_handler(CommandHandler("balance", balance))
    dp.add_handler(CommandHandler("setpair", setpair))
    dp.add_handler(CommandHandler("price", price))
    dp.add_handler(CommandHandler("alert", alert))
    dp.add_handler(CommandHandler("send", send))

    # Handler cho tin nh·∫Øn kh√¥ng ph·∫£i l·ªánh
    dp.add_handler(MessageHandler(Filters.command, unknown))
    dp.add_handler(MessageHandler(Filters.text & ~Filters.command, unknown))

    # L·∫•y ƒë·ªëi t∆∞·ª£ng bot ƒë·ªÉ d√πng trong scheduler
    bot = updater.bot

    # B·∫Øt ƒë·∫ßu polling ƒë·ªÉ nh·∫≠n c·∫≠p nh·∫≠t t·ª´ Telegram
    updater.start_polling()
    logging.info("Bot is polling...")
    updater.idle()
